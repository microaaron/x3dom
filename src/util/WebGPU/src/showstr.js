console.log( "@group(0) @binding(5) var<uniform> isVR: u32;\n@group(0) @binding(6) var<uniform> screenWidth: f32;\n@group(0) @binding(7) var<uniform> cameraPosWS: vec3<f32>;\n@group(0) @binding(8) var<uniform> alphaCutoff: f32;\n@group(0) @binding(9) var<uniform> diffuseColor: vec3<f32>;\n@group(0) @binding(10) var<uniform> specularColor: vec3<f32>;\n@group(0) @binding(11) var<uniform> emissiveColor: vec3<f32>;\n@group(0) @binding(12) var<uniform> shininess: f32;\n@group(0) @binding(13) var<uniform> transparency: f32;\n@group(0) @binding(14) var<uniform> ambientIntensity: f32;\n@group(0) @binding(18) var<uniform> isOrthoView: u32;\n@group(0) @binding(21) var<uniform> light0_On: f32;\n@group(0) @binding(22) var<uniform> light0_On: f32;\n@group(0) @binding(23) var<uniform> light0_Type: f32;\n@group(0) @binding(24) var<uniform> light0_Location: vec3<f32>;\n@group(0) @binding(25) var<uniform> light0_Direction: vec3<f32>;\n@group(0) @binding(26) var<uniform> light0_Color: vec3<f32>;\n@group(0) @binding(27) var<uniform> light0_Attenuation: vec3<f32>;\n@group(0) @binding(28) var<uniform> light0_Radius: f32;\n@group(0) @binding(29) var<uniform> light0_Intensity: f32;\n@group(0) @binding(30) var<uniform> light0_AmbientIntensity: f32;\n@group(0) @binding(31) var<uniform> light0_BeamWidth: f32;\n@group(0) @binding(32) var<uniform> light0_CutOffAngle: f32;\n@group(0) @binding(33) var<uniform> light0_ShadowIntensity: f32;\n\nfn tonemapReinhard(color: vec3<f32>)->vec3<f32>{\n  return color / (color + vec3(1.0));\n}\nfn uncharted2Tonemap(color: vec3<f32>)->vec3<f32>{\n  var A: f32 = 0.15;\n  var B: f32 = 0.50;\n  var C: f32 = 0.10;\n  var D: f32 = 0.20;\n  var E: f32 = 0.02;\n  var F: f32 = 0.30;\n  return ((color*(A*color+C*B)+D*E)/(color*(A*color+B)+D*F))-E/F;\n}\nfn tonemapUncharted2(color: vec3<f32>)->vec3<f32>{\n  var W: f32 = 11.2;\n  var exposureBias: f32 = 2.0;\n  var curr: vec3<f32> = uncharted2Tonemap(exposureBias * color);\n  var whiteScale: vec3<f32> = 1.0 / uncharted2Tonemap(vec3<f32>(W));\n  return curr * whiteScale;\n}\nfn tonemapeFilmic(color: vec3<f32>)->vec3<f32>{\n  var a: f32 = 2.51;\n  var b: f32 = 0.03;\n  var c: f32 = 2.43;\n  var d: f32 = 0.59;\n  var e: f32 = 0.14;\n  return clamp((color * (a * color + b)) / (color * (c * color + d ) + e), 0.0, 1.0);\n}\nfn tonemap(color: vec3<f32>)->vec3<f32>{\n  if(tonemappingOperator == 0.0) {\n    return color;\n  }\n  if(tonemappingOperator == 1.0) {\n    return tonemapReinhard(color);\n  }\n  if(tonemappingOperator == 2.0) {\n    return tonemapUncharted2(color);\n  }\n  if(tonemappingOperator == 3.0) {\n    return tonemapeFilmic(color);\n  }\n}fn lighting(lType: f32,\nlLocation: vec3<f32>,\nlDirection: vec3<f32>,\nlColor: vec3<f32>,\nlAttenuation: vec3<f32>,\nlRadius: f32,\nlIntensity f32,\nlAmbientIntensity f32,\nlBeamWidth f32,\nlCutOffAngle f32,\npositionVS vec3<f32>,\nN vec3<f32>,\nV vec3<f32>,\nshin f32,\nambIntensity f32,\nreflectivity vec3<f32>,\nambient: ptr<function, vec3<f32>>,\ndiffuse: ptr<function, vec3<f32>>,\nspecular: ptr<function, vec3<f32>>){\n  var L: vec3<f32>;\n  var spot: f32 = 1.0;\n  var attentuation: f32 = 0.0;\n  if(lType == 0.0) {\n    L = -normalize(lDirection);\n    V = normalize(V);\n    attentuation = 1.0;\n  }else{\n    L = (lLocation - (-V));\n    var d: f32 = length(L);\n    L = normalize(L);\n    V = normalize(V);\n    if(lRadius == 0.0 || d <= lRadius){\n      attentuation = 1.0 / max(lAttenuation.x + lAttenuation.y * d + lAttenuation.z * (d * d), 1.0);\n    }\n    if(lType == 2.0){\n      var spotAngle: f32 = acos(max(0.0, dot(-L, normalize(lDirection))));\n      if(spotAngle >= lCutOffAngle){spot = 0.0;}\n      else if(spotAngle <= lBeamWidth){spot = 1.0;}\n      else {spot = (spotAngle - lCutOffAngle ) / (lBeamWidth - lCutOffAngle);}\n    }\n  }\n  var H: vec3<f32> = normalize( L + V );\n  var NdotL: f32 = clamp(dot(L, N), 0.0, 1.0);\n  var NdotH: f32 = clamp(dot(H, N), 0.0, 1.0);\n  var ambientFactor: f32 = lAmbientIntensity * ambIntensity;\n  var diffuseFactor: f32 = lIntensity * NdotL;\n  var specularFactor: f32 = lIntensity * pow(NdotH, shin*128.0);\n  *ambient  += lColor * ambientFactor * attentuation * spot;\n  *diffuse  += lColor * diffuseFactor * attentuation * spot;\n  *specular += lColor * specularFactor * attentuation * spot;\n}var<private> gammaEncode4Vector: vec4<f32> = vec4<f32>(0.4545454545454545, 0.4545454545454545, 0.4545454545454545, 1.0);\nvar<private> gammaDecode4Vector: vec4<f32> = vec4<f32>(2.2, 2.2, 2.2, 1.0);\nfn gammaEncodeVec4(color: vec4<f32>)->vec4<f32>{\n  return pow(abs(color), gammaEncode4Vector);\n};\nfn gammaDecodeVec4(color: vec4<f32>)->vec4<f32>{\n  return pow(abs(color), gammaDecode4Vector);\n};\nvar<private> gammaEncode3Vector: vec3<f32> = vec3<f32>(0.4545454545454545, 0.4545454545454545, 0.4545454545454545);\nvar<private> gammaDecode3Vector: vec3<f32> = vec3<f32>(2.2, 2.2, 2.2);\nfn gammaEncodeVec3(color: vec3<f32>)->vec3<f32>{\n  return pow(abs(color), gammaEncode3Vector);\n};\nfn gammaDecodeVec3(color: vec3<f32>)->vec3<f32>{\n  return pow(abs(color), gammaDecode3Vector);\n};\nstruct FragmentOutput {\n  //@builtin(frag_depth) depth: f32,\n  //@builtin(sample_mask) mask_out: u32,\n  @location(0) fragColor0: vec4<f32>\n}\n@fragment\nfn fs_main(\n  //@builtin(front_facing) is_front: bool,\n  //@builtin(position) coord: vec4<f32>,\n  //@builtin(sample_index) my_sample_index: u32,\n  //@builtin(sample_mask) mask_in: u32,\n  @location(0) fragNormal: vec3<f32>,@location(1) fragPosition: vec4<f32>,@location(2) fragPositionWS: vec4<f32>\n) -> FragmentOutput {\n  var fragmentOutput: FragmentOutput ;var color: vec4<f32>;\nvar texColor: vec4<f32>;\ncolor.rgb = diffuseColor;\ncolor.a = 1.0 - transparency;\nvar _emissiveColor: vec3<f32> = emissiveColor;\nvar _shininess: f32 = shininess;\nvar _specularColor: vec3<f32> = specularColor;\nvar _ambientIntensity: f32 = ambientIntensity;\nvar _transparency: f32 = transparency;\nvar _occlusion: f32 = 1.0;var ambient: vec3<f32> = vec3(0.0, 0.0, 0.0);\nvar diffuse: vec3<f32> = vec3(0.0, 0.0, 0.0);\nvar specular: vec3<f32> = vec3(0.0, 0.0, 0.0);\nvar eye: vec3<f32>;\nvar positionVS: vec3<f32> = fragPosition.rgb;\nif ( isOrthoView > 0 ) {\n  eye = vec3<f32>(0.0, 0.0, 1.0);\n}else{\n  eye = -fragPosition.xyz;\n}\nvar normal: vec3<f32> = normalize(fragNormal);\nlighting(light0_Type,\nlight0_Location,\nlight0_Direction,\nlight0_Color,\nlight0_Attenuation,\nlight0_Radius,\nlight0_Intensity,\nlight0_AmbientIntensity,\nlight0_BeamWidth,\nlight0_CutOffAngle,\npositionVS, normal, eye, _shininess, _ambientIntensity, _specularColor, &ambient, &diffuse, &specular);\nambient = max(ambient, 0.0);\ndiffuse = max(diffuse, 0.0);\nspecular = max(specular, 0.0);\ncolor.rgb = _emissiveColor + ((ambient + diffuse) * color.rgb + specular * _specularColor) * _occlusion;\nif(tonemappingOperator == 1.0) {\n  color.rgb = tonemapReinhard(color.rgb);\n}\nif(tonemappingOperator == 2.0) {\n  color.rgb = tonemapUncharted2(color.rgb);\n}\nif(tonemappingOperator == 3.0) {\n  color.rgb = tonemapeFilmic(color.rgb);\n}\ncolor = gammaEncodeVec4(color)fragmentOutput.fragColor0 = color;\nreturn fragmentOutput;\n\n}" );